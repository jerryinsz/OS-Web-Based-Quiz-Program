<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ“ä½œç³»ç»Ÿä¹ é¢˜ç»ƒä¹ </title>
    <style>
        :root { --primary: #0f766e; --correct: #34d399; --wrong: #f87171; --bg: #f0fdfa; }
        body { font-family: 'Segoe UI', "Microsoft YaHei", sans-serif; background: var(--bg); margin: 0; padding: 20px; height: 100vh; display: flex; justify-content: center; box-sizing: border-box; }
        
        .app-wrapper { width: 100%; max-width: 800px; display: flex; flex-direction: column; background: white; border-radius: 16px; box-shadow: 0 10px 25px rgba(0,0,0,0.05); overflow: hidden; height: 100%; }
        
        /* é¡¶éƒ¨æ  */
        .header { padding: 20px; background: white; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; }
        .title-box h2 { margin: 0; font-size: 1.2rem; color: #111827; }
        .progress-badge { background: #ccfbf1; color: #0f766e; padding: 5px 12px; border-radius: 20px; font-weight: bold; font-size: 0.9rem; }

        /* å†…å®¹åŒº */
        .content-area { flex: 1; overflow-y: auto; padding: 30px; display: none; flex-direction: column; }
        .q-stem { font-size: 1.25rem; font-weight: 600; color: #1f2937; line-height: 1.6; margin-bottom: 25px; white-space: pre-wrap; }
        
        /* é€‰é¡¹åˆ—è¡¨ */
        .options-list { display: flex; flex-direction: column; gap: 12px; }
        .option-card { 
            padding: 16px 20px; border: 2px solid #e5e7eb; border-radius: 10px; cursor: pointer; 
            transition: all 0.2s; display: flex; align-items: flex-start; gap: 10px; font-size: 1.05rem; color: #374151;
        }
        .option-card:hover { border-color: #99f6e4; background: #f0fdfa; }
        .option-label { font-weight: 800; min-width: 25px; }

        /* çŠ¶æ€æ ·å¼ */
        .option-card.correct { background: #ecfdf5; border-color: var(--correct); color: #064e3b; }
        .option-card.wrong { background: #fef2f2; border-color: var(--wrong); color: #7f1d1d; }
        .option-card.disabled { pointer-events: none; opacity: 0.8; }

        /* åº•éƒ¨å¯¼èˆª */
        .footer { padding: 20px; border-top: 1px solid #e5e7eb; display: flex; justify-content: space-between; gap: 15px; background: white; }
        .btn { padding: 12px 24px; border-radius: 8px; border: none; cursor: pointer; font-weight: 600; font-size: 1rem; transition: 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { opacity: 0.9; }
        .btn-outline { background: transparent; border: 2px solid var(--primary); color: var(--primary); }

        /* å¯¼å…¥æ¨¡æ€æ¡† */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .modal-box { background: white; width: 90%; max-width: 700px; padding: 30px; border-radius: 16px; display: flex; flex-direction: column; gap: 20px; max-height: 90vh; }
        textarea { width: 100%; height: 300px; padding: 15px; border: 1px solid #cbd5e1; border-radius: 8px; font-family: monospace; resize: vertical; line-height: 1.5; }
        .tips { background: #f3f4f6; padding: 12px; border-radius: 8px; font-size: 0.9rem; color: #4b5563; }
        
        /* ç­”æ¡ˆæ¨ªæ’è¯†åˆ«å¢å¼ºæç¤º */
        .highlight { color: #d946ef; font-weight: bold; }
    </style>
</head>
<body>

<div class="app-wrapper">
    <div class="header">
        <div class="title-box">
            <h2>æ“ä½œç³»ç»Ÿä¹ é¢˜ç»ƒä¹ </h2>
        </div>
        <div class="progress-badge" id="progress">å‡†å¤‡å°±ç»ª</div>
    </div>

    <div class="content-area" id="quiz-view">
        <div class="q-stem" id="q-text"></div>
        <div class="options-list" id="opt-container"></div>
        <div id="feedback" style="margin-top:20px; font-weight:bold; min-height: 24px;"></div>
    </div>

    <div class="footer">
        <button class="btn btn-outline" onclick="showImport()">å¯¼å…¥é¢˜åº“</button>
        <div style="display:flex; gap:10px;">
            <button class="btn btn-primary" id="prev-btn" onclick="nav(-1)">ä¸Šä¸€é¢˜</button>
            <button class="btn btn-primary" id="next-btn" onclick="nav(1)">ä¸‹ä¸€é¢˜</button>
        </div>
    </div>
</div>

<!-- å¯¼å…¥å±‚ -->
<div id="import-modal" class="modal-overlay">
    <div class="modal-box">
        <h3 style="margin:0">ğŸ“„ å¯¼å…¥ä¹ é¢˜</h3>
        <div class="tips">
            1. è¯·å°† <b>é¢˜ç›®</b> å’Œåº•éƒ¨çš„ <b>å‚è€ƒç­”æ¡ˆ</b> å…¨éƒ¨å¤åˆ¶è¿›æ¥ã€‚<br>
            2. ç¨‹åºä¼šè‡ªåŠ¨è¯†åˆ«æ¨ªæ’çš„ç­”æ¡ˆï¼ˆå¦‚ 1. D 2. D ...ï¼‰ã€‚<br>
            3. ç¨‹åºä¼šè‡ªåŠ¨æ‹†åˆ†æŒ¤åœ¨ä¸€è¡Œçš„é€‰é¡¹ï¼ˆå¦‚ A... B...ï¼‰ã€‚
        </div>
        <textarea id="raw-input" placeholder="è¯·ç›´æ¥ç²˜è´´å†…å®¹ï¼Œä¾‹å¦‚ï¼š
1. é¢˜ç›®å†…å®¹...
A. é€‰é¡¹A B. é€‰é¡¹B
...
å‚è€ƒç­”æ¡ˆ
1. D 2. D 3. C"></textarea>
        <button class="btn btn-primary" onclick="parseAndStart()">å¼€å§‹ç»ƒä¹ </button>
    </div>
</div>

<script>
    let questions = [];
    let currentIdx = 0;

    function showImport() { document.getElementById('import-modal').style.display = 'flex'; }

    // --- æ ¸å¿ƒè§£æå¼•æ“ V4.0 ---
    function parseAndStart() {
        const raw = document.getElementById('raw-input').value;
        if (!raw.trim()) return;

        // 1. åˆ†ç¦»é¢˜ç›®åŒºåŸŸå’Œç­”æ¡ˆåŒºåŸŸ
        // é€šå¸¸ç­”æ¡ˆåœ¨æœ€åï¼Œä»¥â€œå‚è€ƒç­”æ¡ˆâ€æˆ–â€œç­”æ¡ˆâ€å¼€å¤´
        let contentPart = raw;
        let answerPart = "";
        
        const answerSplitKeys = ["å‚è€ƒç­”æ¡ˆ", "ç­”æ¡ˆï¼š", "ç­”æ¡ˆ:"];
        for (let key of answerSplitKeys) {
            if (raw.includes(key)) {
                const parts = raw.split(key);
                contentPart = parts[0]; // å‰åŠéƒ¨åˆ†æ˜¯é¢˜ç›®
                answerPart = parts.slice(1).join(key); // ååŠéƒ¨åˆ†æ˜¯ç­”æ¡ˆ
                break;
            }
        }

        // 2. è§£æç­”æ¡ˆï¼ˆæ”¯æŒæ¨ªæ’ï¼š1. D 2. Dï¼‰
        const answerMap = {};
        // æ­£åˆ™ï¼šåŒ¹é… "æ•°å­—" + "é—´éš”" + "A-E"
        // ä½¿ç”¨ global flag åŒ¹é…æ‰€æœ‰å‡ºç°çš„æƒ…å†µ
        const ansRegex = /(\d+)\s*[\.:ï¼]?\s*([A-E])/gi;
        let ansMatch;
        while ((ansMatch = ansRegex.exec(answerPart)) !== null) {
            answerMap[ansMatch[1]] = ansMatch[2].toUpperCase();
        }

        // 3. é¢„å¤„ç†é¢˜ç›®æ–‡æœ¬ï¼šè§£å†³é€‰é¡¹åœ¨åŒä¸€è¡Œçš„é—®é¢˜
        // ç­–ç•¥ï¼šåœ¨æ‰€æœ‰ "A." "B." å‰é¢å¼ºåˆ¶åŠ æ¢è¡Œç¬¦ï¼Œé™¤éå®ƒå·²ç»æ˜¯è¡Œé¦–
        // æ³¨æ„ï¼šåŒ¹é… A. Aã€ Aï¼ (å…¨è§’ç‚¹)
        let formattedContent = contentPart.replace(/(\s)([A-E][\.:ï¼ã€])/g, '\n$2');

        // 4. è§£æé¢˜ç›®
        const lines = formattedContent.split('\n');
        questions = [];
        let currentQ = null;
        
        // é¢˜ç›®å¼€å§‹æ­£åˆ™ï¼šæ•°å­— + ç‚¹/é¡¿å·
        const qStartRegex = /^\s*(\d+)[\.:ï¼ã€]\s*(.*)/;
        // é€‰é¡¹å¼€å§‹æ­£åˆ™
        const optRegex = /^\s*([A-E])[\.:ï¼ã€]\s*(.*)/i;

        lines.forEach(line => {
            line = line.trim();
            if (!line) return;

            // æ£€æŸ¥æ˜¯å¦æ˜¯é¢˜ç›®å¼€å§‹
            let qMatch = line.match(qStartRegex);
            if (qMatch) {
                // å¦‚æœå½“å‰è¡Œè™½ç„¶ä»¥æ•°å­—å¼€å¤´ï¼Œä½†çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªé€‰é¡¹å†…å®¹ï¼ˆä¾‹å¦‚ "1. è¿›ç¨‹..."ï¼‰ï¼Œè¿™é‡Œæœ‰æ­§ä¹‰
                // ä½†é€šå¸¸ "1." åœ¨è¡Œé¦–ä¼˜å…ˆåˆ¤å®šä¸ºé¢˜å·
                
                // æ’é™¤è¯¯åˆ¤ï¼šå¦‚æœè¿™ä¸€è¡Œè¢«åˆ¤å®šä¸ºé¢˜ç›®ï¼Œä½†å®ƒæ˜¯ A. 1. xxx è¿™ç§æƒ…å†µï¼ˆå·²ç»è¢«ä¸Šé¢çš„replaceå¤„ç†è¿‡äº†ï¼Œåº”è¯¥åœ¨è¡Œé¦–ï¼‰
                // æ’é™¤è¯¯åˆ¤ï¼šå¦‚æœè¿™ä¸€è¡Œæ˜¯ "1. D" è¿™ç§çº¯ç­”æ¡ˆè¡Œï¼ˆæœ‰æ—¶å€™ç”¨æˆ·æŠŠç­”æ¡ˆä¹Ÿè´´åœ¨é¢˜ç›®åŒºï¼‰
                if (line.match(/^\d+[\.:ï¼ã€]\s*[A-E]$/i)) return; 

                if (currentQ) questions.push(currentQ);
                
                let id = qMatch[1];
                currentQ = {
                    id: id,
                    title: qMatch[2],
                    options: [],
                    answer: answerMap[id] || null, // è‡ªåŠ¨å…³è”ç­”æ¡ˆ
                    userAns: null
                };
                return;
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯é€‰é¡¹
            let optMatch = line.match(optRegex);
            if (currentQ && optMatch) {
                currentQ.options.push({
                    label: optMatch[1].toUpperCase(),
                    text: optMatch[2]
                });
                return;
            }

            // æ—¢ä¸æ˜¯æ–°é¢˜ä¹Ÿä¸æ˜¯é€‰é¡¹ï¼Œè¿½åŠ åˆ°å½“å‰é¢˜ç›®çš„æè¿°ä¸­
            if (currentQ && !optMatch) {
                // ç®€å•çš„é˜²æŠ–ï¼šä¸è¦æŠŠé¡µçœ‰é¡µè„šåŠ è¿›å»
                if (line.length > 3) currentQ.title += "\n" + line;
            }
        });

        if (currentQ) questions.push(currentQ);

        if (questions.length === 0) {
            alert("æœªèƒ½è¯†åˆ«åˆ°é¢˜ç›®ã€‚è¯·ç¡®ä¿é¢˜ç›®ä»¥ '1.' å¼€å¤´ï¼Œå¹¶åŒ…å« 'å‚è€ƒç­”æ¡ˆ' åŒºåŸŸã€‚");
            return;
        }

        // å¯åŠ¨ç•Œé¢
        document.getElementById('import-modal').style.display = 'none';
        document.getElementById('quiz-view').style.display = 'flex';
        currentIdx = 0;
        loadQuestion();
    }

    // --- æ¸²æŸ“ä¸äº¤äº’ ---
    function loadQuestion() {
        const q = questions[currentIdx];
        
        // æ›´æ–°è¿›åº¦
        document.getElementById('progress').innerText = `é¢˜ç›® ${currentIdx + 1} / ${questions.length}`;
        
        // æ˜¾ç¤ºé¢˜ç›®
        document.getElementById('q-text').innerText = `${q.id}. ${q.title}`;
        
        // æ˜¾ç¤ºé€‰é¡¹
        const container = document.getElementById('opt-container');
        container.innerHTML = '';
        document.getElementById('feedback').innerText = '';

        q.options.forEach(opt => {
            const div = document.createElement('div');
            div.className = 'option-card';
            div.innerHTML = `<span class="option-label">${opt.label}.</span> <span>${opt.text}</span>`;
            div.onclick = () => checkAnswer(opt.label, q);

            // å›æ˜¾çŠ¶æ€
            if (q.userAns) {
                div.classList.add('disabled');
                if (q.answer) {
                    if (opt.label === q.answer) div.classList.add('correct');
                    if (opt.label === q.userAns && opt.label !== q.answer) div.classList.add('wrong');
                } else {
                    // æ²¡æœ‰å½•å…¥ç­”æ¡ˆæ—¶ï¼Œåªé«˜äº®ç”¨æˆ·é€‰çš„
                    if (opt.label === q.userAns) div.style.background = "#e5e7eb";
                }
            }
            container.appendChild(div);
        });

        // ç­”æ¡ˆæç¤ºï¼ˆå¦‚æœæ²¡æœ‰è§£æåˆ°ç­”æ¡ˆï¼‰
        if (q.userAns && !q.answer) {
             document.getElementById('feedback').innerHTML = `<span style="color:#d97706">âš ï¸ ç³»ç»Ÿæœªæ£€æµ‹åˆ°æœ¬é¢˜ç­”æ¡ˆï¼Œè¯·æ ¸å¯¹åŸæ–‡ã€‚</span>`;
        }

        // æŒ‰é’®çŠ¶æ€
        document.getElementById('prev-btn').disabled = currentIdx === 0;
        document.getElementById('next-btn').innerText = currentIdx === questions.length - 1 ? "å®Œæˆ" : "ä¸‹ä¸€é¢˜";
    }

    function checkAnswer(sel, q) {
        if (q.userAns) return;
        q.userAns = sel;
        loadQuestion(); // åˆ·æ–°æ ·å¼

        const fb = document.getElementById('feedback');
        if (q.answer) {
            if (sel === q.answer) {
                fb.innerHTML = `<span style="color:var(--correct)">ğŸ‰ å›ç­”æ­£ç¡®ï¼</span>`;
            } else {
                fb.innerHTML = `<span style="color:var(--wrong)">ğŸ’¥ é”™è¯¯ï¼Œæ­£ç¡®ç­”æ¡ˆæ˜¯ ${q.answer}</span>`;
            }
        }
    }

    function nav(step) {
        const next = currentIdx + step;
        if (next >= 0 && next < questions.length) {
            currentIdx = next;
            loadQuestion();
        }
    }
</script>
</body>
</html>